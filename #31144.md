# [#31144](https://github.com/bitcoin/bitcoin/pull/31144): [IBD] multi-byte block obfuscation

Block obfusaction is way to cipher the block and chainstate contents so that some Antivirus don't flag it, more about it [here](https://github.com/yuvicc/bitcoin-ibd/blob/master/block_obfuscation.md)

## Current obfuscation mechanism
The obfuscation process involves taking the 64bits(8 bytes) key and XORing it with the data being stored or retrieved from the database. So basically bitcoin core
XORs it with the key while storing and XORs it again while reading (this happens during database operations). 
The obfuscation process is done byte by byte, this pr batches them to 64 bit primitives to speed up the obfuscating bigger memory batches.

## Commit diff

- f6689a7d9f81cecccc747fb94d42ca898cb2caef : In this commit we are changing unit tests for xor obfusaction
```sh
diff --git a/src/test/dbwrapper_tests.cpp b/src/test/dbwrapper_tests.cpp
index 3a86036327..3865f014de 100644
--- a/src/test/dbwrapper_tests.cpp
+++ b/src/test/dbwrapper_tests.cpp
@@ -30,18 +30,50 @@ BOOST_AUTO_TEST_CASE(dbwrapper)
 {
     // Perform tests both obfuscated and non-obfuscated.
     for (const bool obfuscate : {false, true}) {
-        fs::path ph = m_args.GetDataDirBase() / (obfuscate ? "dbwrapper_obfuscate_true" : "dbwrapper_obfuscate_false");
-        CDBWrapper dbw({.path = ph, .cache_bytes = 1 << 20, .memory_only = true, .wipe_data = false, .obfuscate = obfuscate});
-        uint8_t key{'k'};
-        uint256 in = m_rng.rand256();
-        uint256 res;
+        constexpr size_t CACHE_SIZE{1_MiB};
+        const fs::path path{m_args.GetDataDirBase() / "dbwrapper"};
+
+        std::vector<uint8_t> obfuscation_key{};
+        std::vector<std::pair<uint8_t, uint256>> key_values{};
+
+        // Write values
+        {
+            CDBWrapper dbw{{.path = path, .cache_bytes = CACHE_SIZE, .wipe_data = true, .obfuscate = obfuscate}};
+            BOOST_CHECK_EQUAL(obfuscate, !dbw.IsEmpty());
+
+            // Ensure that we're doing real obfuscation when obfuscate=true
+            obfuscation_key = dbwrapper_private::GetObfuscateKey(dbw);
+            BOOST_CHECK_EQUAL(obfuscate, !is_null_key(obfuscation_key));
+
+            for (uint8_t k{0}; k < 10; ++k) {
+                uint8_t key{k};
+                uint256 value{m_rng.rand256()};
+                BOOST_CHECK(dbw.Write(key, value));
+                key_values.emplace_back(key, value);
+            }
+        }

-        // Ensure that we're doing real obfuscation when obfuscate=true
-        BOOST_CHECK(obfuscate != is_null_key(dbwrapper_private::GetObfuscateKey(dbw)));
+        // Verify that the obfuscation key is never obfuscated
+        {
+            CDBWrapper dbw{{.path = path, .cache_bytes = CACHE_SIZE, .obfuscate = false}};
+            BOOST_CHECK(obfuscation_key == dbwrapper_private::GetObfuscateKey(dbw));
+        }
 
-        BOOST_CHECK(dbw.Write(key, in));
-        BOOST_CHECK(dbw.Read(key, res));
-        BOOST_CHECK_EQUAL(res.ToString(), in.ToString());
+        // Read back the values
+        {
+            CDBWrapper dbw{{.path = path, .cache_bytes = CACHE_SIZE, .obfuscate = obfuscate}};
+
+            // Ensure obfuscation is read back correctly
+            BOOST_CHECK(obfuscation_key == dbwrapper_private::GetObfuscateKey(dbw));
+            BOOST_CHECK_EQUAL(obfuscate, !is_null_key(obfuscation_key));
+
+            // Verify all written values
+            for (const auto& [key, expected_value] : key_values) {
+                uint256 read_value{};
+                BOOST_CHECK(dbw.Read(key, read_value));
+                BOOST_CHECK_EQUAL(read_value, expected_value);
+            }
+        }
```
Instead of magic number (1 << 20), we are directly assigning the value which is the preferred way(`constexpr size_t CACHE_SIZE{1_MiB};`). `.wipe_data = true` which means we are wiping the data each 
time we are done with testing, this is basically helpful as we don't need to maintain 2 differnt files 
(`fs::path ph = m_args.GetDataDirBase() / (obfuscate ? "dbwrapper_obfuscate_true" : "dbwrapper_obfuscate_false"`).
We can just use `dbwrapper` for true as well as false value. 

------------------------------------------------------------------------------------------------------------------------------------------------------

```sh
diff --git a/src/test/streams_tests.cpp b/src/test/streams_tests.cpp
diff --git a/src/test/streams_tests.cpp b/src/test/streams_tests.cpp
index c7b5cd353e..d19d23f924 100644
--- a/src/test/streams_tests.cpp
+++ b/src/test/streams_tests.cpp
@@ -13,19 +13,78 @@
 #include <boost/test/unit_test.hpp>
 
 using namespace std::string_literals;
+using namespace util::hex_literals;
 
 BOOST_FIXTURE_TEST_SUITE(streams_tests, BasicTestingSetup)
 
+// Test that obfuscation can be properly reverted even with random chunk sizes.
+BOOST_AUTO_TEST_CASE(xor_roundtrip_random_chunks)
+{
+    auto apply_random_xor_chunks{[&](std::span<std::byte> target, const std::span<std::byte, sizeof(uint64_t)> obfuscation) {
+        for (size_t offset{0}; offset < target.size();) {
+            const size_t chunk_size{1 + m_rng.randrange(target.size() - offset)};
+            util::Xor(target.subspan(offset, chunk_size), obfuscation, offset);
+            offset += chunk_size;
+        }
+    }};
+
+    for (size_t test{0}; test < 100; ++test) {
+        const size_t write_size{1 + m_rng.randrange(100U)};
+        const std::vector original{m_rng.randbytes<std::byte>(write_size)};
+        std::vector roundtrip{original};
+
+        std::array<std::byte, sizeof(uint64_t)> key_bytes{};
+        if (m_rng.randbool()) m_rng.fillrand(key_bytes);
+        apply_random_xor_chunks(roundtrip, key_bytes);
+
+        // Verify intermediate state differs from original unless the key is all zeros
+        const bool all_zeros{std::ranges::all_of(
+            std::span{key_bytes}.first(std::min(write_size, key_bytes.size())), [](auto b) { return b == std::byte{0}; })};
+        BOOST_CHECK_EQUAL(original != roundtrip, !all_zeros);
+
+        apply_random_xor_chunks(roundtrip, key_bytes);
+        BOOST_CHECK(original == roundtrip);
+    }
+}
+
+// Compares optimized obfuscation against a trivial byte-by-byte reference implementation
+// with random offsets to ensure proper handling of key wrapping.
+BOOST_AUTO_TEST_CASE(xor_bytes_reference)
+{
+    auto expected_xor{[](std::span<std::byte> target, const std::span<const std::byte, sizeof(uint64_t)> obfuscation, size_t key_offset) {
+        for (auto& b : target) {
+            b ^= obfuscation[key_offset++ % obfuscation.size()];
+        }
+    }};
+
+        }
+    }};
+
+    for (size_t test{0}; test < 100; ++test) {
+        const size_t write_size{1 + m_rng.randrange(100U)};
+        const size_t key_offset{m_rng.randrange(3 * 8U)}; // Should wrap around
+        const size_t write_offset{std::min(write_size, m_rng.randrange(sizeof(uint64_t) * 2))};
+
+        std::array<std::byte, sizeof(uint64_t)> key_bytes{};
+        if (m_rng.randbool()) m_rng.fillrand(key_bytes);
+        std::vector expected{m_rng.randbytes<std::byte>(write_size)};
+        std::vector actual{expected};
+
+        expected_xor(std::span{expected}.subspan(write_offset), key_bytes, key_offset);
+        util::Xor(std::span{actual}.subspan(write_offset), key_bytes, key_offset);
+
+        BOOST_CHECK_EQUAL_COLLECTIONS(expected.begin(), expected.end(), actual.begin(), actual.end());
+    }
+}
```




 



